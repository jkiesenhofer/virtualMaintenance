<html>
<head>
    <link rel="stylesheet" href="mailForm_.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
<img src="https://shorturl.la/pixel/1748056184132141659" width="1" height="1" alt="" />
<div id="chart" style="width: 100%; height: 500px;"></div>
<script>
	
	var qr = {};
	// the parseInt method analyzes a value as string of 
	// characters and returns a float parseString as prompt omits user input.
	// const number = parseInt(prompt('Calibrates a solid interface impedance'));
	const number = 22;
        let point1 = 0, point2 = 1, point3;

        class Volume {
          constructor(controlGate, heatRate, laser) {
             this.controlGate = controlGate;
	     this.laser = heatRate;
	     this.heatRate = laser;
          }
        }

	// program to identify an interpolated qr code position | v/sqrt(m^2/s^2)
        const nand = { ['233']: '6,6', ['15625']: '52', ['264']: '28.1' , ['377']: '10.54' };

	const volume = new
        Volume([0,0,0], [1,1,1], [7,7,3])
        
        const volume2 = new
        Volume({ [0]: 3, [0]: 6 },
               { [1]: 5, [1]: 2 },
               { [2]: 0, [2]: 1 })

	qr.point1 = parseInt("104.18.187.229");
	qr.point2 = parseInt("109.199.115.41");
	qr.point3 = parseInt("93.37.250.70");
	qr.point4 = parseInt("65.183.218.91");
	qr.point5 = parseInt("65.183.218.92");
	qr.point6 = parseInt("58.71.56.79");
	qr.point7 = parseInt("65.183.218.94");
	qr.point8 = parseInt("204.225.1.66");
	qr.point9 = parseInt("183.25.195.195");
	qr.point10 = parseInt("190.76.97.216");
	qr.point11 = parseInt("208.114.40.25");
	qr.point12 = parseInt("171.124.90.73");
	qr.point13 = parseInt("132.210.213.67");
	qr.point14 = parseInt("28.48.16.9");
	qr.point15 = parseInt("195.179.153.172");
	qr.point16 = parseInt("5.129.190.108");
	qr.point17 = parseInt("187.38.255.160");
	qr.point18 = parseInt("99.130.104.212");
	qr.point19 = parseInt("211.117.82.189");
	qr.point20 = parseInt("210.39.216.139");
	qr.point21 = parseInt("214.142.239.59");
	qr.point22 = parseInt("104.48.34.203");
	qr.point23 = parseInt("142.88.240.76");
	qr.point24 = parseInt("63.124.25.244");
	qr.point25 = parseInt("5.193.26.33");
	qr.point26 = parseInt("165.133.2.156");
	qr.point27 = parseInt("165.163.168.157");
	qr.point28 = parseInt("252.98.199.25");
	qr.point29 = parseInt("246.167.151.55");
	qr.point30 = parseInt("73.210.112.159");

        const array = [];
        array[30]=Object.values(qr);
        //console.log(array.toString().split("'"));
        const trace = {
          x: [48.0167, 51.2215, 9.1885, -122.2054, -122.2054, 121.0410, -122.2054, 13.6500],
          y: [-123.3832, -123.3832, 14.7047, 6.8624, 15.5325,121.0390, -123.3832, 15.5325],
          mode: 'markers',
          type: 'scatter'
        };
        const layout = {
          xaxis: { title: 'Latitude e.g. 16°22′19.00″E' },
          yaxis: { title: 'Longitude e.g. 48°12′30.00″N' }
        };
        // draw the plot
        Plotly.newPlot('chart', [trace], layout);
	//console.log('ray density:',volume.controlGate);
        //console.log('low deposition:',volume2.heatRate);
        //console.log('heat flux vector:',volume2.laser);
        // rules the open interval [-131;131[
	//console.log(nand['15625']);
	// expected results: 52

	const dirac = function lambda(u) {
	  const v = 1;
  	  //return u-2 < v ? v : (((u+2) ** lambda(u-2)-3)**3)/264;
	  return u-2 < v ? v : (((u+2) ** lambda(u-2)-3)**2)/264;
	};
		
	function mixedFraction (p) {
	  var pressure = p.virtual;
	  var z = 0;
	  // computes every 10ms
	  var liquid = setInterval(frame, 10)

	  function frame () {
	    //pressure.interpolation.point = z + '%' ;
	    z++;
	    if (z === 9) {
	      clearInterval (solid) ;
	    }
	    for (let i = 0; i < 80; i++) {
            console.log(i.toString()+' : '+(dirac(i)+264).toString())
            }
	  }
	}
	
	//mixedFraction(volume2.controlGate);
	// prevents optic object from calling the frame function

	function heatMap(k) {
	   if (Number.isNaN(Number.parseFloat(k))) {
	     return 0;
	   }
	   return parseFloat(k) * 2.0 * Math.PI;
	}
	/* the static Number.parseFloat() method transforms an argument into a
           floating-point number and returns a floating-point string. 
           If a number cannot contribute to the argument, it returns NaN. */
       
        const impedance = {};
        const polarization = ' of ';

	class viscosity {
           constructor(x, y, z, polarization) {
	      this.x = Number.parseFloat(x);
  	      this.y = Number.isNaN(Number.parseFloat(y));
	      this.z = impedance.surface;
	      this.polarization = impedance.surface.toString().length/2;
	      // The isNaN() method returns a true result if a value is not a number.
          }
        }

        impedance.surface = 4*13;  // digital froude surface tension
	//console.log(heatMap(impedance.surface));
	// expected results: 326.7256359733385

        const convexity = new
        viscosity(377e-05, 233, 377, 1) // with 63,55 g/mol
        let t = impedance.surface.toString();
        //console.log(convexity);
        // expected results: viscosity { x: 0.00377, y: false, z: 52, polarization: 1 }

	let parseString = polarization.length;
	// literal strings can be 
	// specified using single quotation marks or 
	// double quotes, which are treated in the same way.

	//console.log(parseString,t.length);
	// Expected results: 4 2
	
        const controlGate = [];
	controlGate[1] = 10946;
	controlGate[5] = 377;
	// accesses the variable as a dictionary key
        // order of converted elements is default.
	controlGate.sort();

	const heatRate = [];
	heatRate[4] = 3375;
	heatRate[5] = 233;
        heatRate.sort();

        // declares the function or variable that limits the flow
        let factorial = nand['15625'];
        // returns a surface tension prediction instance
        //console.log(factorial.length);
	// expected result: 2

        var $private = [controlGate,heatRate];
	
	Number.MAX_SAFE_INTEGER;
	// the data property represents the maximum safe integer in JavaScript 2^53-1
	
	const containerLabel = new Date();
	let servertime = containerLabel.toUTCString();
	// the toUTCString() method returns a UTC date object.
	let vector = servertime.split(" ");
	// divides a string into an array of substrings
	
	let gmt = "";
	for (let i = 0; i < vector.length; i++) {
	  gmt += vector[i]+' ';
	}

	let arg1  = Math.floor(Math.random()*impedance.surface);
	// the Math.floor() method is used in scenarios 
	// where you need to perform integer division
	let arg2 = "Viscosity of zink: 20.9e-06Pas";
	//alert(!(arg1 & arg2)); // expected result: true
	//alert(arg1 && arg2);     // expected result: arg2
        
        const accountData = (function(){
        const $private = new WeakMap();
        // pairs of elements or values processed
        function hybris() {
	// hybris() creates an object in a private space
        // set syntax links the interface function to the object
        $private.set(impedance,{verification:'heatRate'});
        }
        hybris.prototype.connect = function(){
	// with the exception of the null prototype, all objects have 
	// interface properties accessing private values.
        $private.get(vector).verification;
        }
        return hybris;
        })();
	//console.log(gmt)
	let id = qr.point9;
	for (let j = 0; j < 30; j++) {
        //console.log('Impedance diffusion','[',j,']:',dirac(j)+id);
        }
	// transforms the dependency of points without sorting
        //console.log('Fibonacci:');
        for (let i = 1; i <= number; i++){
        //console.log(point1);
        point3 = point1 + point2;
        point1 = point2;
        point2 = point3;
        };

	for (let i = 0; i < 5; i++) {
	//console.log(“Interface transfer with”,$private[0][i], “bit memory”);
	//console.log(“Interface transfer with”,$private[1][i], “bit memory”);
        }
        Object.getOwnPropertyDescriptor(factorial,controlGate);

	function followers(){
	// shuffle mixing algorithm
	let followers = ["Hearts", "Diamonds", "Clubs", "Spades"];
        let values = [
            "Ace","King","Queen","Jack",
            "2", "3", "4", "5", "6",
            "7", "8", "9", "10",
        ];

        let res = [];

	// the push() method adds new elements to the end of an array.
        for (let follower in followers) {
            for (let value in values) {
                res.push(values[value] + " " + followers[follower]);
            }
        }

        for (let i = res.length - 1; i > 0; i--) {
            let j = Math.floor(Math.random() * (i + 1));
            [res[i], res[j]] = [res[j], res[i]];
        }

	let arg="";
        for (let j = 2; j > 0;j--){
            arg = arg+'\n'+res[res.length-j];
        }
	// returns the two top followers
        alert(arg);
	}

	var keyField = Math.random()
        var virtualValue1 = ((keyField * 1e9) | 0) / 1e9
	var virtualValue2 = ((keyField * 1e9) | 0) / 1e9

	let height = "1,83";
        const follower = height.split(",");
        //console.log(follower[1]);

</script>

<audio controls autoplay muted>
        <source src="audio.mp3" type="audio/mp3">
</audio>


<table border="1" id="myTable">
  <thead>
    <tr>
      <th>x</th>
      <th>IPV4</th>
      <th>City</th>
      <th>ID</th>
      <th>Longitude</th>
      <th>Error</th>
      <th>Latitude</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</th>
      <td>104.18.187.229</td>
      <td>Vocklabruck</td>
      <td>104.18.187.229</td>
      <td>15.5325</td>
      <td>1.8825°W</td>
      <td>48.0167</td>
    </tr>
    <tr>
      <td>1</th>
      <td>109.199.115.41</td>
      <td>Dusseldorf</td>
      <td>109.199.115.41</td>
      <td>6.8624</td>
      <td>0.0862°W</td>
      <td>51.2215</td>
    </tr>
    <tr>
      <td>2</th>
      <td>93.37.250.70</td>
      <td>Milan</td>
      <td>93.37.250.70</td>
      <td>14.7047</td>
      <td>30.7596°W</td>
      <td>9.1885</td>
    </tr>
    <tr>
      <td>3</th>
      <td>65.183.218.91</td>
      <td>East Cathlamet</td>
      <td>65.183.218.91</td>
      <td>-123.3832</td>
      <td>-168.4022°N</td>
      <td>-122.2054</td>
    </tr>
    <tr>
      <td>4</th>
      <td>65.183.218.92</td>
      <td>Bothell</td>
      <td>65.183.218.92</td>
      <td>-123.3832</td>
      <td>171.1454°N</td>
      <td>-122.2054</td>
    </tr>
    <tr>
      <td>5</th>
      <td>58.71.56.79</td>
      <td>Mandaluyong City</td>
      <td>58.71.56.79</td>
      <td>121.0390</td>
      <td>106.4559°W</td>
      <td>121.0410</td>
    </tr>
    <tr>
      <td>6</th>
      <td>65.183.218.94</td>
      <td>Bothell</td>
      <td>65.183.218.94</td>
      <td>-123.3832</td>
      <td>-75.621°N</td>
      <td>-122.2054</td>
    </tr>
  </tbody>
</table>

<script>

        const tableToDict = (tableId) => {
        const table = document.getElementById(tableId);
        const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.textContent.trim());
        const rows = Array.from(table.querySelectorAll("tbody tr"));

        return rows.map(row => {
        const cells = Array.from(row.querySelectorAll("td"));
        return headers.reduce((acc, header, index) => {
        acc[header] = cells[index].textContent.trim();
        return acc;
        }, {});
        });
        };
        const tableDict = tableToDict("myTable");
        console.log(tableDict);

</script>

<!--
<div class="bleu">
	<h2>Black Jack</h2>
	<input type="text" id="384" placeholder="Croupière" name="rsa" required>
	<input type="password" id="384" placeholder="Password" name="password" required>
        <input type="button" value="submit" onclick="cards()"/>
</div>
-->
</body>
</html>
